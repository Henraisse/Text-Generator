def fillInTheInput(self, tag, templateSentLem, templateSent, corpusSents, taggedInput):
        notFound = True

        while notFound:
            i = 0
            for tupl in templateSentLem:
                print(tag),'tag'
                print(tupl[1]),'tupl1'
                if tag == tupl[1]:
                    templateSentLem[i] = taggedInput[0]
                    notFound = False
                    break
                i = i+1
            if notFound == True:
                templateSentLem, templateSent  = self.findTemplet(corpusSents)

        #print(templateSent)
        return templateSentLem, templateSent, i



        def buildLeft(self, taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j):
        "This function builds the left side of the sentence"
        #the place where we did put the input is i
        i = i-1

        #base case : we've passed the first taggedInput
        if i <= -1:
            return templetSentLem

        #normal case
        tuple1 = templetSentLem[i]
        wordTag = tuple1[1] #Get the current tag we want to find a taggedInput to
        word1 = tuple1[0]

        #TODO this is just for now and does not seem to work
        #if wordTag in {'TO', 'WP','-NONE-','WDT','CC'}:                                         #If we get a weird tag, save it for later. Or never, idk
            #return self.buildLeft(taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j)                   #Continue the recursion
        if word1 in stopwords.words('english'):#{'TO', 'WP','-NONE-','WDT','CC','PRP','IN','VBP'}:
            print('hoppar stopordet')
            return self.buildRight(taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j)



        #get the inner dictionary for the input taggedInput
        #TODO - - - FIND A METHOD THAT RETRIEVES THE PRE-NEIGHBOR INSTEAD OF POST-NEIGHBOR
        nextWordList = bigram[taggedInput]                                                             #Retrieve the neighboring words for our current taggedInput


        nwlSameToken = []                                                                       #Make a new list of words to put these in there
        for w in nextWordList:                                                                  #Check each taggedInput: if the taggedInput has the same tag
            if pos_tag(word_tokenize(w[0])) == wordTag:                                         #If the taggedInput has correct tag:
                nwlSameToken.append(taggedInput)                                                       #add the fitting taggedInput to our list

        #if no words with the right Tag exist in the list of the words that use to follow
        if len(nwlSameToken) == 0:
            mostProbWord = self.randomWordWithRightTag(taggedCorpus, wordTag)                        #retrieve a random taggedInput
            templetSentLem[i] = mostProbWord                                                       #fill in the gap with the mostProbWord, i.e. the random taggedInput with correct tag
            return self.buildLeft(taggedCorpus, mostProbWord, templetSentLem, bigram, trigram, i, j)#(taggedCorpus, mostProbWord[0], templetSentLem, bigram, trigram, i, 1)        #rerun the recursion

        #If there are words and we choose the most probable one
        else:
            sortedNextWordList = sorted(nextWordList.items(), key = operator.itemgetter(1))     #tag the taggedInput and see if it is right
            mostProbWordWithTag = sortedNextWordList[j]                                         #the taggedInput is put in the telmpet
            templetSentLem[i] = mostProbWordWithTag                                                #continue to the next taggedInput
            return self.buildLeft(taggedCorpus, mostProbWordWithTag, templetSentLem, bigram, trigram, i, j)    #rerun the recursion
        return templetSentLem