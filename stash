def fillInTheInput(self, tag, templateSentLem, templateSent, corpusSents, taggedInput):
        notFound = True

        while notFound:
            i = 0
            for tupl in templateSentLem:
                print(tag),'tag'
                print(tupl[1]),'tupl1'
                if tag == tupl[1]:
                    templateSentLem[i] = taggedInput[0]
                    notFound = False
                    break
                i = i+1
            if notFound == True:
                templateSentLem, templateSent  = self.findTemplet(corpusSents)

        #print(templateSent)
        return templateSentLem, templateSent, i



        def buildLeft(self, taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j):
        "This function builds the left side of the sentence"
        #the place where we did put the input is i
        i = i-1

        #base case : we've passed the first taggedInput
        if i <= -1:
            return templetSentLem

        #normal case
        tuple1 = templetSentLem[i]
        wordTag = tuple1[1] #Get the current tag we want to find a taggedInput to
        word1 = tuple1[0]

        #TODO this is just for now and does not seem to work
        #if wordTag in {'TO', 'WP','-NONE-','WDT','CC'}:                                         #If we get a weird tag, save it for later. Or never, idk
            #return self.buildLeft(taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j)                   #Continue the recursion
        if word1 in stopwords.words('english'):#{'TO', 'WP','-NONE-','WDT','CC','PRP','IN','VBP'}:
            print('hoppar stopordet')
            return self.buildRight(taggedCorpus, taggedInput, templetSentLem, bigram, trigram, i, j)



        #get the inner dictionary for the input taggedInput
        #TODO - - - FIND A METHOD THAT RETRIEVES THE PRE-NEIGHBOR INSTEAD OF POST-NEIGHBOR
        nextWordList = bigram[taggedInput]                                                             #Retrieve the neighboring words for our current taggedInput


        nwlSameToken = []                                                                       #Make a new list of words to put these in there
        for w in nextWordList:                                                                  #Check each taggedInput: if the taggedInput has the same tag
            if pos_tag(word_tokenize(w[0])) == wordTag:                                         #If the taggedInput has correct tag:
                nwlSameToken.append(taggedInput)                                                       #add the fitting taggedInput to our list

        #if no words with the right Tag exist in the list of the words that use to follow
        if len(nwlSameToken) == 0:
            mostProbWord = self.randomWordWithRightTag(taggedCorpus, wordTag)                        #retrieve a random taggedInput
            templetSentLem[i] = mostProbWord                                                       #fill in the gap with the mostProbWord, i.e. the random taggedInput with correct tag
            return self.buildLeft(taggedCorpus, mostProbWord, templetSentLem, bigram, trigram, i, j)#(taggedCorpus, mostProbWord[0], templetSentLem, bigram, trigram, i, 1)        #rerun the recursion

        #If there are words and we choose the most probable one
        else:
            sortedNextWordList = sorted(nextWordList.items(), key = operator.itemgetter(1))     #tag the taggedInput and see if it is right
            mostProbWordWithTag = sortedNextWordList[j]                                         #the taggedInput is put in the telmpet
            templetSentLem[i] = mostProbWordWithTag                                                #continue to the next taggedInput
            return self.buildLeft(taggedCorpus, mostProbWordWithTag, templetSentLem, bigram, trigram, i, j)    #rerun the recursion
        return templetSentLem










        def buildRightTri(self, taggedCorpus, taggedInput, templateSentLem, templateSent, bigramc, trigram, i, j, bool):
        i = i+1
        #find one word with bigram
        if i >= 1:
            #print('end of sent')
            return templateSentLem
        #take the word and the next word tuples, send them as templateSentLem
        if bool == True:
            tupleOne = templateSentLem[i-1]
            tupleTwo = templateSentLem[i]
            listToUseForBigram = [tupleOne,tupleTwo]
            firstTupleForTrigram = self.buildRight(taggedCorpus, taggedInput, listToUseForBigram, templateSent, bigramc, trigram, 0, -1)
            templateSentLem[i] = firstTupleForTrigram[1]
            bool = False


        tuple1 = templateSentLem[i]
        wordTag = tuple1[1]
        word1 = tuple1[0]
        #print wordTag
        nwlSameToken = []

        if word1 in stopwords.words('english'):#{'TO', 'WP','-NONE-','WDT','CC','PRP','IN','VBP'}:
            #print('hoppar stopordet')
            return self.buildRghtTri(taggedCorpus, taggedInput, templateSentLem, templateSent, bigramc, trigram, i, j, True)
        else:
            word2 =
            if word1 in bigramc:
                nextWordList = bigramc[word1]
                #print(nextWordList),'nextwordlist'

                for w in nextWordList:
                    #print w, 'finns i listan'
                    if pos_tag(w[0]) == wordTag:
                        nwlSameToken.append(w)
                        #print(nwlSameToken), 'all the words with same token'
            else:
                #todo, we should handle this in some other way
               # print 'No such key', word1
                return self.buildLeft(taggedCorpus, taggedInput, templateSentLem, templateSent, bigramc, trigram, i, j)
        #get the inner dictionary for the input word
        #TODO i think that this never happens, i donn

        #if no words with the right Tag exist in the list of the words that use to follow
        if len(nwlSameToken) == 0:
            tag = wordTag
            mostProbWord = self.randomWordWithRightTag(taggedCorpus, wordTag)
            templateSentLem[i] = mostProbWord
            #print mostProbWord[0]
            #print 'no next word'
            return self.buildLeft(taggedCorpus, mostProbWord, templateSentLem, templateSent, bigramc, trigram, i, j)
            #print(tag_templet)
        #If there are words and we choose the most probable one
        else:
            sortedNextWordList = sorted(nextWordList.items(), key = operator.itemgetter(1))
            wordWithProb = sortedNextWordList[j]
            mostProbWordWithTag = pos_tag(wordWithProb[0])
            #the word is put in the telmpet
            templateSentLem[i] = mostProbWordWithTag
            #continue to the next word
            #print 'go on'
            return self.buildLeft(taggedCorpus, mostProbWordWithTag, templateSentLem, templateSent, bigramc, trigram, i, j)
        #print('jag returnerar', templateSentLem)
        return templateSentLem




